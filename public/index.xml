<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>OranLooney.com</title>
    <link>/</link>
    <description>Recent content on OranLooney.com</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en</language>
    <copyright>&amp;copy; Copyright 2018 Oran Looney</copyright>
    <lastBuildDate>Wed, 20 Nov 2019 00:00:00 +0000</lastBuildDate>
    
	<atom:link href="/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>ML From Scratch, Part 1: Linear Regression</title>
      <link>/post/ml-from-scratch-part-1-lm/</link>
      <pubDate>Wed, 20 Nov 2019 00:00:00 +0000</pubDate>
      
      <guid>/post/ml-from-scratch-part-1-lm/</guid>
      <description>To kick off this series, will start with something simply yet foundational: linear regression via ordinary least squares.
Wait! don’t go yet!
We’re going to do it right, using QR decomposition. This is the same (or very close to the same) method your favorite statistical software uses under the hood, and its quite a bit more interesting than the way its usually presented to first-time students. Assuming you find linear algebra interesting, which I do, otherwise why would you be reading this?</description>
    </item>
    
    <item>
      <title>ML From Scratch, Part 0: Introduction</title>
      <link>/post/ml-from-scratch-part-0-introduction/</link>
      <pubDate>Tue, 12 Nov 2019 00:00:00 +0000</pubDate>
      
      <guid>/post/ml-from-scratch-part-0-introduction/</guid>
      <description>MotivationHow do you know if you really understand something? You could just rely on the subjective experience of feeling like you understand. This sounds plausible - surely you yourself of all people should know, right? But it runs head-first into in the (Dunning-Kruger effect)DK. A different criterion is found in this pithy quote:
“What I cannot create, I do not understand.” - Richard Feynman
This is a very famous and popular quote, but there are various ways of interpreting it, perhaps the most common interpretation could be paraphrased as, “what I cannot explain to a layperson and a curious child, I do not understand.</description>
    </item>
    
    <item>
      <title>Visualizing Multiclass Classification Results</title>
      <link>/post/viz-tsne/</link>
      <pubDate>Thu, 23 Aug 2018 00:00:00 +0000</pubDate>
      
      <guid>/post/viz-tsne/</guid>
      <description>Introduction Visualizing the results of a binary classifier is already a challenge, but having more than two classes aggrevates the matter considerably.
Let&amp;rsquo;s say we have $k$ classes. Then for each observation, there is one correct prediction and $k-1$ possible incorrect prediction. Instead of a $2 \times 2$ confusion matrix, we have a $k^2$ possibilities. Instead of having two kinds of error, false positives and false negatives, we have $k(k-1)$ kinds of errors.</description>
    </item>
    
    <item>
      <title>Craps Variants</title>
      <link>/post/craps-game-variants/</link>
      <pubDate>Wed, 11 Jul 2018 00:00:00 +0000</pubDate>
      
      <guid>/post/craps-game-variants/</guid>
      <description>Craps is a suprisingly fair game. I remember calculating the probability of winning craps for the first time in an undergraduate discrete math class: I went back through my calculations several times, certain there was a mistake somewhere. How could it be closer than $\frac{1}{36}$?
(Spoiler Warning If you haven&amp;rsquo;t calculated these odds for yourself then you may want to do so before reading further. I&amp;rsquo;m about to spoil it for you rather thoroughly in the name of exploring a more general case.</description>
    </item>
    
    <item>
      <title>Complex Numbers in R, Part II</title>
      <link>/post/complex-r-part-2/</link>
      <pubDate>Sat, 30 Jun 2018 00:00:00 +0000</pubDate>
      
      <guid>/post/complex-r-part-2/</guid>
      <description>This post is part of a series on complex number functionality in the R programming language. You may want to read Part I before continuing if you are not already comfortable with the basics.
In Part I of this series, we dipped our toes in the water by explicitly creating some complex numbers and showing how they worked with the most basic mathematical operators, functions, and plots.
In this second part, we’ll take a more in-depth look at some scenarios where complex numbers arise naturally – where they are less of a choice an more of a necessity.</description>
    </item>
    
    <item>
      <title>Complex Numbers in R, Part I</title>
      <link>/post/complex-r/</link>
      <pubDate>Sun, 17 Jun 2018 00:00:00 +0000</pubDate>
      
      <guid>/post/complex-r/</guid>
      <description>R, like many scientific programming languages, has first-class support for complex numbers. And, just as in most other programming languages, this functionality is ignored by the vast majority of users.
Yet complex numbers can often offer surprisingly elegant formulations and solutions to problems. I want to convince you that familiarizing yourself with R’s excellent complex number functionality is well worth the effort and will pay off in two different ways: first by showing you how they are so amazingly useful you’ll want to go out of your way to use them, and then by showing you how they are so common and fundamental to modern analysis that you couldn’t avoid them if you wanted to.</description>
    </item>
    
    <item>
      <title>Your First Two R Packages</title>
      <link>/post/r-first-two/</link>
      <pubDate>Sat, 16 Jun 2018 00:00:00 +0000</pubDate>
      
      <guid>/post/r-first-two/</guid>
      <description>Don’t Start With Vanilla!It’s natural to assume you should learn the built-in libraries of a new language before moving on to third-party libraries. Unfortunately, when it comes to R, there are key areas where the built-in functionality is so terrible, and so out-dated, and so full of impossible-to-remember abbreviations, and frankly not very good even once you do learn it, that it’s best to start with a few high quality libraries and treat the built-in functionality as advanced functionalty that you’ll come back and learn when you need to interface with legacy code.</description>
    </item>
    
    <item>
      <title>So, Apparently I&#39;m an iPad Developer Now</title>
      <link>/post/apparently-ipad-developer/</link>
      <pubDate>Wed, 28 Apr 2010 00:00:00 +0000</pubDate>
      
      <guid>/post/apparently-ipad-developer/</guid>
      <description>Last week my boss stopped by and dropped a brand spanking new iPad on my desk.&amp;quot;Make our application work on this,&amp;quot; he commanded. &amp;quot;You have two days before we demo it at the trade show.&amp;quot; Madness? No, these are web apps! You see, for the last couple years we&#39;ve beenworking exclusively on AJAX applications: web pages stuffed with so muchJavaScript they look and feel like desktop apps. It&#39;s harder than writingdesktop software, but if you pull it off you get an application that can berun anywhere, instantly.</description>
    </item>
    
    <item>
      <title>Deep Copy in JavaScript</title>
      <link>/post/deep-copy-javascript/</link>
      <pubDate>Wed, 25 Nov 2009 00:00:00 +0000</pubDate>
      
      <guid>/post/deep-copy-javascript/</guid>
      <description>Update 2017-10-23: This article and code library have not kept up with the rapidly changing JavaScript landscape and are now hopelessly out of date. First came non-enumerable properties, and with ES2015 came the introduction of classes, proxies, symbols, and anonymous functions, all of which break the below logic. I&#39;m afraid I no longer know how to fully copy the full menagerie of JavaScript objects while preserving relative references, and it&#39;s quite possible that no one else knows either.</description>
    </item>
    
    <item>
      <title>Semantic Code</title>
      <link>/post/semantic-code/</link>
      <pubDate>Wed, 30 Apr 2008 00:00:00 +0000</pubDate>
      
      <guid>/post/semantic-code/</guid>
      <description>se-man-tic (si-man&amp;rsquo;tik) adj. &amp;nbsp; &amp;nbsp; 1. Of or relating to meaning, especially meaning in language.
 Programming destroys meaning. When we program, we first replace concepts with symbols and then replace those symbols with arbitrary codes &amp;mdash; that&amp;rsquo;s why it&amp;rsquo;s called coding.
At its worst programming is write-only: the program accomplishes a task, but is incomprehensible to humans. See, for example, the story of Mel. Such a program is correct, yet at the same time meaningless.</description>
    </item>
    
  </channel>
</rss>
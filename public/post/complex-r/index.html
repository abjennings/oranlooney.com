<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0">
  <title>Complex Numbers in R - OranLooney.com</title>
  <meta property="og:title" content="Complex Numbers in R - OranLooney.com" />
  <meta name="twitter:title" content="Complex Numbers in R - OranLooney.com" />
  <meta name="description" content="R, like many scientific programming languages, has first-class support for complex numbers. And, just as in most other programming languages, this functionality is ignored by the vast majority of users.
Yet complex numbers can often offer surprisingly elegant formulations and solutions to problems. I want to convince you that familiarizing yourself with R’s excellent complex number functionality is well worth the effort and will pay off tenfold in two different ways: first by showing you how they are so amazingly useful you’ll want to go out of your way to use them, and then by showing you how they are so common and fundamental to modern analysis that you couldn’t avoid them if you wanted to.">
  <meta property="og:description" content="R, like many scientific programming languages, has first-class support for complex numbers. And, just as in most other programming languages, this functionality is ignored by the vast majority of users.
Yet complex numbers can often offer surprisingly elegant formulations and solutions to problems. I want to convince you that familiarizing yourself with R’s excellent complex number functionality is well worth the effort and will pay off tenfold in two different ways: first by showing you how they are so amazingly useful you’ll want to go out of your way to use them, and then by showing you how they are so common and fundamental to modern analysis that you couldn’t avoid them if you wanted to.">
  <meta name="twitter:description" content="R, like many scientific programming languages, has first-class support for complex numbers. And, just as in most other programming languages, this functionality is ignored by the vast majority of …">
  <meta name="author" content="Oran Looney"/>
  <meta property="og:site_name" content="OranLooney.com" />
  <meta property="og:url" content="/post/complex-r/" />
  <meta property="og:type" content="article" />
  <meta property="og:image" content="/post/complex-r_files/mandala.png" />
  <meta name="twitter:image" content="/post/complex-r_files/mandala.png" />
  <meta name="twitter:card" content="summary" />
  <meta name="generator" content="Hugo 0.42.1" />
  <link rel="stylesheet" href="/css/style.css" media="all" />
  <link rel="stylesheet" href="/css/syntax.css" media="all" />
  <link rel="stylesheet" href="/css/custom.css" media="all" />

  <script src="https://code.jquery.com/jquery-3.2.1.min.js" integrity="sha256-hwg4gsxgFZhOsEEamdOYGBf13FyQuiTwlAQgxVSNgt4=" crossorigin="anonymous" async></script>

  <script defer src="https://use.fontawesome.com/releases/v5.0.10/js/all.js" integrity="sha384-slN8GvtUJGnv6ca26v8EzVaR9DC58QEwsIk9q1QXdCU8Yu8ck/tL/5szYlBbqmS+" crossorigin="anonymous" async></script>

 
</head>

<body>

<header class="site-header">
  <nav class="site-navi">
    
    <a href="/" class="site-title">OWL</a>
    <ul class="site-navi-items">
      <li class="site-navi-item-"><a href="/tags/" title="Tags">Tags</a></li>
      <li class="site-navi-item-"><a href="/archives/" title="Archives">Archives</a></li>
      <li class="site-navi-item-about"><a href="/about/" title="About">About</a></li>
    </ul>
    
  <ul class="author-social">
    <li><a href="https://github.com/olooney" target="_blank"><i class="fab fa-github"></i></a></li>
    <li><a href="https://stackoverflow.com/users/273231/olooney" target="_blank"><i class="fab fa-stack-overflow"></i></a></li>
    <li><a href="http://honeycode.tumblr.com" target="_blank"><i class="fab fa-tumblr"></i></a></li>
    <li><a href="https://www.librarything.com/catalog.php?view=olooney&offset=0&shelf_rows=10&previousOffset=0&shelf=shelf" target="_blank" title="library"><i class="far fa-bookmark"></i></a></li>
    
  </ul>

  </nav>
</header>
<hr class="site-header-bottom">


  <div class="main" role="main">
    <article class="article">
      <img src="/post/complex-r_files/mandala.png" class="article-image" />
      
      <h1 class="article-title">Complex Numbers in R</h1>
      
      <hr class="article-title-bottom">
      <ul class="article-meta">
        <li class="article-meta-date"><time>June 17, 2018</time></li>
        <li class="article-meta-tags">
          <a href="/tags/r/">
            <i class="fas fa-tag"></i>
            R
          </a>&nbsp;
        </li>
        <li class="article-meta-tags">
          <a href="/tags/math/">
            <i class="fas fa-tag"></i>
            Math
          </a>&nbsp;
        </li>
      </ul>
      
<aside class="toc">
  
</aside>
      <p>R, like many scientific programming languages, has first-class support for complex numbers. And, just as in most other programming languages, this functionality is ignored by the vast majority of users.</p>
<p>Yet complex numbers can often offer surprisingly elegant formulations and solutions to problems. I want to convince you that familiarizing yourself with R’s excellent complex number functionality is well worth the effort and will pay off tenfold in two different ways: first by showing you how they are so amazingly useful you’ll want to go out of your way to use them, and then by showing you how they are so common and fundamental to modern analysis that you couldn’t avoid them if you wanted to.</p>
<div id="pythagorean-triples" class="section level2">
<h2>Pythagorean Triples</h2>
<p>Let’s start with a problem which <em>could</em> be solved in other ways, but is greatly simplified by the introduction of complex numbers that it almost seems magical.</p>
<p>A Pythagorean triple is an integer solution to the Pythagorean equation:</p>
<p><span class="math display">\[
a^2 + b^2 = c^2 \quad\quad a,b,c \in \mathbb{N}^+ \tag{1}
\]</span></p>
<p>You probably learned at least one of these in school – the famous 3, 4, 5 triangle:</p>
<p><img src="/post/complex-r_files/345.gif" alt="3-4-5 triangle"></p>
<p>In general <a href="https://en.wikipedia.org/wiki/Diophantine_equation">Diophantine equations</a> – which require <em>integer</em> solutions – can be quite hard to solve, so it might surprise you to hear that it’s almost trivially easy to write down an infinite of Pythagorean triples. Well, it’s easy if we use complex numbers, anyway.</p>
<p>A Gaussian integer is a complex number where both the real and imaginary parts are integers:</p>
<p><span class="math display">\[
  Z[i] = \{ x + iv \mid x,y \in \mathbb{Z} \} \tag{2}
\]</span></p>
<p>So one way of stating the problem of finding all Pythagorean triples is to find all Gaussian integers Which are an integer distance away from the origin. The distance of a complex number from the origin is called its “norm” and denoted <span class="math inline">\(\lVert z \rVert\)</span>.</p>
<p><span class="math display">\[
  T = \{ z \in \mathbb{C} \mid \lVert z \rVert \in \mathbb{Z} \} \tag{3}
\]</span></p>
<p>Now, in general the norm of Gaussian integer will be the square root of an integer (the integer <span class="math inline">\(u^2 + v^2\)</span> to be precise.) Therefore if we square a Gaussian integer, it will have an integer norm and therefore represent a Pythagorean triple!</p>
<p><span class="math display">\[
\forall z \in Z[i], z^2 \in T \tag{4}
\]</span></p>
<p>So that’s a pretty good start: just a few minutes work, and we’ve already found an <em>infinite number</em> of Pythagorean triples, and we have a computationally trivial way of constructing new triples: we simply pick any two positive integers <span class="math inline">\(u\)</span> and <span class="math inline">\(v\)</span> and then square the complex number <span class="math inline">\(u + iv\)</span>.</p>
<p>Before address the more difficult question of whether or not we’ve found all possible Pythagorean triples using this construction, let’s switch over to R and do some code our solution so far.</p>
<p>Our algorithm first requires us to pick pairs of positive integers. Just to be thorough, we’ll take all such pairs up to an arbitrary threshold.</p>
<p>Now, if we wanted just one or two complex numbers, we could use the literal syntax:</p>
<pre class="r"><code>triples &lt;- c( 3+4i, 5+12i, 9+12i )</code></pre>
<p>But since we want them along a grid, we’ll use the <code>complex()</code> constructor. The constructor is vectorized so by passing in two vectors of equal length we can construct a one-dimensional vector of complex numbers.</p>
<pre class="r"><code>n = 400
grid &lt;- expand.grid(u=1:(2*n), v=1:(2*n))
grid &lt;- grid[ grid$u &gt; grid$v, ]
gaussian_integers &lt;- complex(real=grid$u, imaginary=grid$v)</code></pre>
<p>Per the theoretical discussion above, we can generate Pythagorean triples by simply squaring these. All primitive math functions in R work just as well on complex numbers: <code>exp</code>, <code>log</code>, <code>sin</code>, <code>cos</code>and of course exponentiation:</p>
<pre class="r"><code>triples &lt;- gaussian_integers^2

# display the 10 with the smallest norm
cat( triples[order(Mod(triples))][1:10], sep=&quot;\n&quot;)</code></pre>
<pre><code># 3+4i
# 8+6i
# 5+12i
# 15+8i
# 12+16i
# 7+24i
# 24+10i
# 21+20i
# 16+30i
# 35+12i</code></pre>
<p>Did it work? We’re certainly seeing some familiar pairings there, like <span class="math inline">\(5+12i\)</span> which maps to well-known triple <span class="math inline">\((5,12,13)\)</span>. To visualize them, we can simply pass our complex vector to R’s <code>plot()</code> function - it will conveniently plot them in the complex plane for us!</p>
<pre class="r"><code>triples &lt;- triples[ Re(triples) &lt;= n &amp; Im(triples) &lt;= n ]

# helper function to colorize complex points by their angle.
argcolor &lt;- function(z) hsv(Arg(z)*2/pi, s=0.9, v=0.8)

plot(
  triples, 
  col=argcolor(triples),
  pch=20,
  xlim=c(0,n),
  ylim=c(0,n),
  main=paste(&quot;Squared Gaussian Integers Up to&quot;, n)
)</code></pre>
<p><img src="/post/complex-r_files/figure-html/triples-1.png" width="672" /></p>
<p>Now it turns out that our algorithm does not, in fact, generate all possible triples. One thing it misses are multiples: if <span class="math inline">\((3,4,5)\)</span> is a triple, then <span class="math inline">\((6,8,10)\)</span> should be a triple, and <span class="math inline">\((9,12,15)\)</span> should be a triple, and so on. So we have to expand our set to have all multiples.</p>
<pre class="r"><code>multiples &lt;- lapply(1:(floor(n/3)), function(m) triples*m)
triples &lt;- unique(do.call(c, multiples))</code></pre>
<p>It also turns out that in the special case where both integers are even we can divide by two and get a new triple that was missed by the initial net we cast. But that’s the end of the special cases – with this final rule in place, we’re now guaranteed to hit <em>every</em> Pythagorean triple.</p>
<pre class="r"><code>halves &lt;- triples[ Re(triples) %% 2 == 0 &amp; Im(triples) %% 2 == 0 ] / 2
triples &lt;- unique(c(triples, halves))</code></pre>
<p>Now all we need to is clean up duplicates and duplicate along the mirror line of symmetry…</p>
<pre class="r"><code>triples &lt;- triples[ Re(triples) &lt;= n &amp; Im(triples) &lt;= n]
triples &lt;- c(triples, complex(real=Im(triples), imaginary=Re(triples)))</code></pre>
<p>..and we’re finally ready to visualize the real solution.</p>
<pre class="r"><code>plot(triples, col=argcolor(triples), pch=20)
title(paste(&quot;All Pythagorean Triples Up to&quot;, n))</code></pre>
<p><img src="/post/complex-r_files/figure-html/plotall-1.png" width="672" /></p>
<p>That’s too many to really understand, although there are definitely patterns emerging. Let’s zoom in and just plot a small region,but with more detail.</p>
<pre class="r"><code>small_n = 25
small_triples &lt;- triples[ Re(triples) &lt; small_n &amp; Im(triples) &lt; small_n ]
small_triples &lt;- small_triples[ order(Mod(small_triples), decreasing=TRUE) ]

# plot points
plot(
  small_triples, 
  pch=20,
  ylim=c(0,small_n), 
  xlim=c(0,small_n),
  ylab=&quot;b&quot;, xlab=&quot;a&quot;)

# add triangles. Can&#39;t rely on automatic complex plane plotting here.
segments(
  Re(small_triples), Im(small_triples), 
  0, 0, 
  col=argcolor(small_triples))
segments(
  Re(small_triples), Im(small_triples), 
  Re(small_triples), 0, 
  col=argcolor(small_triples))
segments(
  Re(small_triples), 0, 
  0, 0, 
  col=argcolor(small_triples))

# points again, so that they&#39;re in the foreground.
points(small_triples, pch=20, col=argcolor(triples), cex=1)

# text label for the points
text(
  x=small_triples + 1i, 
  cex=0.8,
  labels=paste0(
    &quot;(&quot;, 
    Re(small_triples), 
    &quot;,&quot;,
    Im(small_triples),
    &quot;,&quot;,
    Mod(small_triples),
    &quot;)&quot;
  )
)
title(paste(&quot;Pythagorean Triples Up to&quot;, small_n))</code></pre>
<p><img src="/post/complex-r_files/figure-html/plotsmall-1.png" width="672" /></p>
<p>On the zoomed in view we can see each Pythagorean triple represented as a right triangle; we can see that the integer multiples of solutions form a series of similar triangles; we can see that there’s a strong symmetry with every triple <span class="math inline">\((a,b,c)\)</span> having a partner <span class="math inline">\((b,a,c)\)</span> which is its mirror reflection about the like <span class="math inline">\(y=x\)</span>.</p>
<p>From the zoomed out view we can see that the region close to either axis is essentially devoid of solutions; that their radii (e.g. close to 50) where triples are dense, and others where they are rare to non-existent; and it looks as if triples actually get less dense as we move away from the origin.</p>
<p>This last observation, about triples thinning out as we move away from the origin, can be understood and quantified by once again using the complex plane. Triples are more or less the squares of Gaussian integers; we can say the number of triples with norm less than <span class="math inline">\(r\)</span> is roughly proportional to the number of Gaussian integers in the first quadrant and inside a circle with radius <span class="math inline">\(\sqrt{r}\)</span>, which is roughly proportional to the area of the quarter-circle of radius <span class="math inline">\(\sqrt{r}\)</span>, which is <span class="math inline">\(\frac{\pi r}{4}\)</span> or very roughly just <span class="math inline">\(r\)</span>.</p>
</div>
<div id="complex-roots-and-eigenvalues" class="section level2">
<h2>Complex Roots and Eigenvalues</h2>
<blockquote>
<p>Some problems are specific to complex numbers, some problems can be made easier by a complex representation, and some problems have complex numbers thrust upon them.</p>
<p>– <cite>William Shakespeare, 12 + 5i Night</cite></p>
</blockquote>
<p>The Pythagorean Triples gave us an opportunity to dip our toes in the water by explicitly create some complex numbers and manipulating them in fairly basic ways. Next let’s look at a some examples where complex are less of a choice an more of a necessity. One such case that is of interest to statisticians and scientists (I’m assuming you’re not using R for embedded systems or game development) is solving the <a href="https://en.wikipedia.org/wiki/Eigenvalues_and_eigenvectors">eignproblem</a> for a non-symmetric matrix.</p>
<p>Now, if your only exposure to eigenvalues is through <a href="https://en.wikipedia.org/wiki/Principal_component_analysis">PCA</a>, you might not even be aware that eigenvalues are usually complex numbers… even when the original matrix is comprised only of real numbers! However PCA is actually a very special case: a covariance matrix is <em>always</em> a symmetric, positive-definite, real-valued matrix, therefore its eigenvalues are always positive real numbers.</p>
<p>However, there are plenty of situations in statistics where a non-symmetric matrix arises naturally and the eigenvalues can give us deep insight into the problem. Two such are <a href="https://en.wikipedia.org/wiki/Markov_chain">Markov Chains</a> and <a href="https://en.wikipedia.org/wiki/Autoregressive_model">AR models</a>. Let’s only look at a simple example of an AR model - that will suffice to demonstrate R’s complex number functionality in this domain.</p>
<p>Let’s start by constructing a small time series that exhibits very strong autocorrelation. To get some interesting behavior, I will give it a strongly positive one day correlation, but then reverse it the next day. This should give us both decay and oscillations.</p>
<pre class="r"><code>set.seed(43)
t_0 &lt;- zoo(rnorm(n=100))
t_1 &lt;- lag(t_0, k=1, na.pad=TRUE)
t_2 &lt;- lag(t_0, k=2, na.pad=TRUE)
t_3 &lt;- lag(t_0, k=3, na.pad=TRUE)
t &lt;- na.omit(t_0 + 0.7*t_1 - 0.2*t_2 + 0.2*t_3)
plot(t, type=&#39;l&#39;)
title(&#39;Time Series With Autocorrelation&#39;)</code></pre>
<p><img src="/post/complex-r_files/figure-html/ts-1.png" width="672" /></p>
<pre class="r"><code>pacf(t) # Partial Autocorrelation Plot</code></pre>
<p><img src="/post/complex-r_files/figure-html/ts-2.png" width="672" /></p>
<p>Next we construct the model. While I normally recommend the <a href="https://cran.r-project.org/web/packages/forecast/index.html">forecast</a> package, we’ll just use the built-in <code>ar()</code> function today.</p>
<pre class="r"><code>ar_model &lt;- ar(t)
ar_model</code></pre>
<pre><code># 
# Call:
# ar(x = t)
# 
# Coefficients:
#       1        2        3        4        5  
#  0.5078  -0.4062   0.3481  -0.3960   0.2462  
# 
# Order selected 5  sigma^2 estimated as  1.19</code></pre>
<p>That’s roughly what we’d expect based on how we constructed the time series and what we saw on the partial autocorrelation plot: A strong positive autocorrelation at lag one, a slightly less strong negative autocorrelation at lag 2, then some harmonics.</p>
<pre class="r"><code>ar_coefs &lt;- ar_model$ar  # coefficients(ar_model) doesn&#39;t work, IDK why
roots &lt;- polyroot( c(1,-ar_coefs) )
roots</code></pre>
<pre><code># [1]  0.7158218+1.1364815i -0.6823253+0.9974625i -0.6823253-0.9974625i
# [4]  0.7158218-1.1364815i  1.5417367+0.0000000i</code></pre>
<pre class="r"><code>plot(
  1/roots, 
  ylim=c(-1,1), 
  asp=1,
  main=&quot;Inverse AR Roots&quot;,
  panel.first=c(
    lines(complex(modulus=1, argument=0.01*2*pi)^(0:100), col=&#39;grey&#39;),
    abline(h=0, col=&#39;grey&#39;),
    abline(v=0, col=&#39;grey&#39;)
  )
)</code></pre>
<p><img src="/post/complex-r_files/figure-html/roots-1.png" width="672" /></p>
<p>Just to be clear, we’re plotting the <em>inverse</em> roots, so we’d expect them to be <em>inside</em> the unit circle if the process is stationary.</p>
<p>(Just as an Easter egg, we also used complex numbers to plot the unit circle. If you’re not sure how that worked, just remember that multiplying complex numbers adds their arguments – their angle with the x-axis – together.)</p>
<p>Just from looking at the roots and observing that some are far from the real axis, we can also say that this time series will experience a back-and-forth oscillations as each day tries to “correct” for the previous day. If the influence of history merely decayed away smoothly and exponentially, all the roots would have been close to the real axis. (It’s a common misconception that how long effects last is related to the <em>order</em> of the model; when in fact even an AR(1) model can have a very long memory if it has its root close to 1.)</p>
<p>Plotting the inverse roots of ARIMA models is standard practice because it can help you diagnose <a href="https://en.wikipedia.org/wiki/Stationary_process">non-stationary series</a> and near <a href="https://en.wikipedia.org/wiki/Unit_root">unit roots</a>, both of which can ruin the predictive power and interpretability of a model. There’s no getting away from the fact that a polynomial of degree two or higher might have complex roots.</p>
<p>But there’s another way of looking at an AR model - as a <a href="https://en.wikipedia.org/wiki/Linear_dynamical_system">discrete linear dynamical system.</a> Let’s call the value of our at the <span class="math inline">\(n\)</span>-th step <span class="math inline">\(t_n\)</span>. Then we can define our state vectors to be</p>
<p><span class="math display">\[
\boldsymbol{t}_n = \begin{bmatrix}
  t_n \\
  t_{n-1} \\
  t_{n-2} \\
  t_{n-3} \\
  t_{n-4} \\
  \end{bmatrix}
\]</span></p>
<p>In other words, we just stack <span class="math inline">\(t_n\)</span> with it’s first four lags. That may not seem like an improvment, but now we can write</p>
<p><span class="math display">\[
\boldsymbol{t}_{n+1} =\boldsymbol{F} \boldsymbol{t}_n
\]</span></p>
<p>or more explicitly:</p>
<p><span class="math display">\[
  \begin{bmatrix}
  t_{n+1} \\
  t_{n} \\
  t_{n-1} \\
  t_{n-2} \\
  t_{n-3} \\
  \end{bmatrix} = \boldsymbol{F}
  \begin{bmatrix}
  t_n \\
  t_{n-1} \\
  t_{n-2} \\
  t_{n-3} \\
  t_{n-4} \\
  \end{bmatrix}
\]</span></p>
<p>where <span class="math inline">\(\boldsymbol{F}\)</span> is the “forward time evolution” matrix. This basically says we can always compute the state of our time series at the next time step by applying a <em>linear</em> operator to the prevous state. And in fact, we already have a good idea what the matrix <span class="math inline">\(\boldsymbol{F}\)</span> should look like. For one thing, it’s clear that the four lagged components can simply be grabbed from the old state by shifting down by one:</p>
<p><span class="math display">\[
  \begin{bmatrix}
  t_{n+1} \\
  t_{n} \\
  t_{n-1} \\
  t_{n-2} \\
  t_{n-3} \\
  \end{bmatrix} = 
    \begin{bmatrix}
  . &amp; . &amp; . &amp; . &amp; . \\
  1 &amp; 0 &amp; 0 &amp; 0 &amp; 0 \\
  0 &amp; 1 &amp; 0 &amp; 0 &amp; 0 \\
  0 &amp; 0 &amp; 1 &amp; 0 &amp; 0 \\
  0 &amp; 0 &amp; 0 &amp; 1 &amp; 0 \\
  \end{bmatrix}
  \begin{bmatrix}
  t_n \\
  t_{n-1} \\
  t_{n-2} \\
  t_{n-3} \\
  t_{n-4} \\
  \end{bmatrix}
\]</span></p>
<p>And from the coeeficients of the AR(1) model we built before, we know that <span class="math inline">\(t_n\)</span> can be expressed as a linear sum of <span class="math inline">\(t_{n-1}\)</span> through <span class="math inline">\(t_{n-4}\)</span>:</p>
<p><span class="math display">\[
  \begin{bmatrix}
  t_{n+1} \\
  t_{n} \\
  t_{n-1} \\
  t_{n-2} \\
  t_{n-3} \\
  \end{bmatrix} = 
    \begin{bmatrix}
  0.508 &amp; -0.406 &amp; 0.348 &amp; -0.396 &amp; 0.246 \\
  1 &amp; 0 &amp; 0 &amp; 0 &amp; 0 \\
  0 &amp; 1 &amp; 0 &amp; 0 &amp; 0 \\
  0 &amp; 0 &amp; 1 &amp; 0 &amp; 0 \\
  0 &amp; 0 &amp; 0 &amp; 1 &amp; 0 \\
  \end{bmatrix}
  \begin{bmatrix}
  t_n \\
  t_{n-1} \\
  t_{n-2} \\
  t_{n-3} \\
  t_{n-4} \\
  \end{bmatrix}
\]</span></p>
<p>So now that, we’ve determined the linear operator <span class="math inline">\(\boldsymbol{F}\)</span> for our dynamic system, we can ask what happens to the system 2 time-steps into the future, then 3, and so on. It should be clear that we can simply apply <span class="math inline">\(\boldsymbol{F}\)</span> again and again to determine <em>any</em> future state, so that in general the state at time <span class="math inline">\(n\)</span> is</p>
<p><span class="math display">\[
\boldsymbol{t}_n = \boldsymbol{F}^n \boldsymbol{t}_0
\]</span></p>
<p>But raising a matrix to a power is particularly easy if we know its eigenvalues. Let’s say <span class="math inline">\(\boldsymbol{F} = \boldsymbol{Q} \boldsymbol{\Lambda} \boldsymbol{Q}^{-1}\)</span> is the eigen-decomposition, where <span class="math inline">\(\boldsymbol{Q}\)</span> is an orthogonal matrix and <span class="math inline">\(\boldsymbol{\Lambda}\)</span> is the diagonal matrix of eigenvalues. Then</p>
<p><span class="math display">\[
  \boldsymbol{F}^2 = \boldsymbol{F} \boldsymbol{F} =
  \boldsymbol{Q} \boldsymbol{\Lambda} \boldsymbol{Q}^{-1}
  \boldsymbol{Q} \boldsymbol{\Lambda} \boldsymbol{Q}^{-1}
  = \boldsymbol{Q} \boldsymbol{\Lambda}^2 \boldsymbol{Q}^{-1}
\]</span></p>
<p>This clearly generalizes to any power by induction. Also, raising a diagonal matrix to a power is completely trivial: you simply raise each independent element to its power.</p>
<p><span class="math display">\[
\boldsymbol{\Lambda}^n = \begin{bmatrix}
  \lambda_1^n &amp; 0 &amp; 0 &amp; 0 &amp; 0 \\
  0 &amp; \lambda_2^n &amp; 0 &amp; 0 &amp; 0 \\
  0 &amp; 0 &amp; \lambda_3^n &amp; 0 &amp; 0 \\
  0 &amp; 0 &amp; 0 &amp; \lambda_4^n &amp; 0 \\
  0 &amp; 0 &amp; 0 &amp; 0 &amp; \lambda_5^n
\end{bmatrix}
\]</span></p>
<p>A few things are immediately obvious. Each eigenvalue is a complex number; so if its norm is less than 1 it will tend to 0 as <span class="math inline">\(n\)</span> increases, or if its norm is greater than 1 it will tend to <span class="math inline">\(\infty\)</span>, or if its norm is exactly 1 it will always be exactly 1. Furthermore, if the eigenvalue is real, it will always be real, but if it is not real then it will rotate about the origin by a fixed angle with every time step. Thus, it will exhibit some kind of oscilation with a frequency determined by its argument. Each eigenvalue will behave independently, but if <em>every</em> eigenvalue has norm less than 1, then the system as a whole will converge to a steady state at 0.</p>
<p>So now that I’ve hopefully impressed upon you the importance of eigenvalues is understanding the dynamics of our system, let’s actually compute them. And, just for fun let’s compare them to the roots of the lag polynomial from above.</p>
<pre class="r"><code>ar_matrix &lt;- matrix( nrow=5, ncol=5, byrow=TRUE, c(
  0.5078, -0.4062,   0.3481,  -0.3960,   0.2462, 
       1,       0,        0,        0,        0,
       0,       1,        0,        0,        0,
       0,       0,        1,        0,        0,
       0,       0,        0,        1,        0))

ar_eigen &lt;- eigen(ar_matrix)
df &lt;- t(rbind(data.frame(t(sort(1/roots))), data.frame(t(sort(ar_eigen$values)))))
colnames(df) &lt;- c(&quot;Inverse AR(5) Roots&quot;, &quot;Time Evolution Eigenvalues&quot;)</code></pre>
<table>
<thead>
<tr class="header">
<th align="center">Inverse AR(5) Roots</th>
<th align="center">Time Evolution Eigenvalues</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="center">-0.467 + 0.683i</td>
<td align="center">-0.467 - 0.683i</td>
</tr>
<tr class="even">
<td align="center">-0.467 - 0.683i</td>
<td align="center">-0.467 + 0.683i</td>
</tr>
<tr class="odd">
<td align="center">0.397 + 0.630i</td>
<td align="center">0.397 - 0.630i</td>
</tr>
<tr class="even">
<td align="center">0.397 - 0.630i</td>
<td align="center">0.397 + 0.630i</td>
</tr>
<tr class="odd">
<td align="center">0.649 - 0.000i</td>
<td align="center">0.649 + 0.000i</td>
</tr>
</tbody>
</table>
<p>Hey, wait just a minute here! What are you trying to pull here, buddy? Those are (to within numerical precision) exactly the same as the inverse roots!</p>
<p>Yes, it’s true. This is very obvious if we plot them together:</p>
<pre class="r"><code>plot(
  ar_eigen$values, 
  ylim=c(-1,1), 
  xlim=c(-1,1),
  asp=1,
  cex=2,
  main=&quot;Inverse AR Roots&quot;,
  panel.first=c(
    lines(complex(modulus=1, argument=0.01*2*pi)^(0:100), col=&#39;grey&#39;),
    abline(h=0, col=&#39;grey&#39;),
    abline(v=0, col=&#39;grey&#39;)
  )
)

points(
  1/roots, 
  pch=4,
  cex=2,
  col=&#39;red&#39;
)</code></pre>
<p><img src="/post/complex-r_files/figure-html/eigenplot-1.png" width="672" /></p>
<p>They are exactly the same. You’re welcome to prove this is exactly true by writing down the characteristic polynomial for a matrix in this form and verifying its the same polynomial we found the roots for in the AR formulation of the problem.</p>
<p>In fact, you can see the many parallels in the two approaches: in one analysis, we said that an AR model would only be stationary if all its inverse roots were inside the unit circle, in the other we said the dynamic system would converge to a steady state at the origin. Different language, indeed two historically different mathematical treatments, but the same conclusions. In both cases we found that the system was characterized by a sequence of 5 complex numbers, and that both the norm and the argument of each number meaningfully impacted the behavior of the system. And so on.</p>
<p>There’s no escaping it: those 5 complex numbers <em>are</em> the best way to understand this system, and any sufficiently sophisticated approach will lead us to this same conclusion.</p>
<p>Let’s just take a moment to realize what happened to us here: we started from a data set entirely comprised of real numbers, built a model with real number values for all parameters (two models in fact: a regression and matrix) but in the end we still had to understand our model in terms of complex numbers. The real numbers are not closed under many interesting and natural operations - work with real numbers long enough, and eventually you’ll be working in the complex plane. This is not infrequent and hopefully these examples have demonstrated that its extremely helpful familiarize yourself with R’s capabilities in this regard.</p>
</div>

    </article>

    <hr>


    <ul class="pager article-pager">
      <li class="pager-newer pager-noitem">&lt; Newer</li>
      <li class="pager-older">
        <a href="/post/apparently-ipad-developer/" data-toggle="tooltip" data-placement="top" title="So, Apparently I&#39;m an iPad Developer Now">Older &gt;</a>
      </li>
    </ul>
  </div>


<div class="site-footer">
  <div class="copyright">&copy; Copyright 2018 Oran Looney</div>
  <ul class="site-footer-items">
  </ul>
  <div class="powerdby">
    Powered by <a href="https://gohugo.io/">Hugo</a> and <a href="https://github.com/taikii/whiteplain">Whiteplain</a>
  </div>
</div>
<script src="/js/script.js"></script>
<script src="/js/custom.js"></script>


<script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS_HTML"></script>
<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  tex2jax: {
    inlineMath: [ ['$','$'], ["\\(","\\)"] ],
    displayMath: [ ["\\[","\\]"] ],  // ['$$','$$'], 
    processEscapes: true,
    processEnvironments: true
  },
  // Center justify equations in code and markdown cells. Elsewhere
  // we use CSS to left justify single line equations in code cells.
  displayAlign: 'center',
  "HTML-CSS": {
    styles: {'.MathJax_Display': {"margin": 0}},
    linebreaks: { automatic: true }
  }
});
</script>


<link rel="stylesheet"
	href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css">
<script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js"></script>
<script>
  hljs.configure({
    languages: ['python', 'r', 'javascript']
  })
  hljs.initHighlightingOnLoad()
</script>



</body>
</html>

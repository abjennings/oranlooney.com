<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Cracking Playfair Ciphers - OranLooney.com</title>
  <meta property="og:title" content="Cracking Playfair Ciphers - OranLooney.com" />
  <meta name="twitter:title" content="Cracking Playfair Ciphers - OranLooney.com" />
  <meta name="description" content="In 2020, the Zodiac 340 cipher was finally cracked after more than 50 years of trying by amateur code breakers. While the effort to crack it was extremely impressive, the cipher itself was ultimately disappointing. A homophonic substitution cipher with a minor gimmick of writing diagonally, the main factor that prevented it from being solved much earlier were the several errors made when encoding it.
Substitution ciphers, which operate at the level of a single character, are basically children&rsquo;s toys, the kind of thing you might get a decoder ring for from the back of a magazine.">
  <meta property="og:description" content="In 2020, the Zodiac 340 cipher was finally cracked after more than 50 years of trying by amateur code breakers. While the effort to crack it was extremely impressive, the cipher itself was ultimately disappointing. A homophonic substitution cipher with a minor gimmick of writing diagonally, the main factor that prevented it from being solved much earlier were the several errors made when encoding it.
Substitution ciphers, which operate at the level of a single character, are basically children&rsquo;s toys, the kind of thing you might get a decoder ring for from the back of a magazine.">
  <meta name="twitter:description" content="In 2020, the Zodiac 340 cipher was finally cracked after more than 50 years of trying by amateur code breakers. While the effort to crack it was extremely impressive, the cipher itself was ultimately â€¦">
  <meta name="author" content="Oran Looney"/>

  <meta name="generator" content="Hugo 0.42.1" />
  <link rel="stylesheet" href="/css/style.css" media="all" />
  <link rel="stylesheet" href="/css/syntax.css" media="all" />
  <link rel="stylesheet" href="/css/custom.css" media="all" />

  <script src="https://code.jquery.com/jquery-3.2.1.min.js" integrity="sha256-hwg4gsxgFZhOsEEamdOYGBf13FyQuiTwlAQgxVSNgt4=" crossorigin="anonymous" async></script>

  <script defer src="https://use.fontawesome.com/releases/v5.15.4/js/all.js" integrity="sha384-rOA1PnstxnOBLzCLMcre8ybwbTmemjzdNlILg8O7z1lUkLXozs4DHonlDtnE7fpc" crossorigin="anonymous" async></script>
 
</head>

<body>
<header class="site-header">
  <nav class="site-navi">
    <a href="/" class="site-title">OWL</a>
    <ul class="site-navi-items">
      <li class="site-navi-item">
        <a href="/search/" title="Site Search"><i class="fa fa-search"></i></a>
      </li>
      <li class="site-navi-item">
        <a href="/tags/" title="Article Tags"><i class="fa fa-tag"></i></a>
      </li>
      <li class="site-navi-item">
        <a href="/archives/" title="Article Archives"><i class="fa fa-archive"></i></a>
      </li>
      <li class="site-navi-item">
        <a href="/quotes/" title="Favorite Quotes"><i class="fas fa-quote-right"></i></a>
      </li>
      <li class="site-navi-item">
        <a href="/about/" title="About Me"><i class="fa fa-info-circle"></i></a>
      </li>
    </ul>
    
  <ul class="author-social">
    <li><a href="//honeycode.tumblr.com/" target="_blank" title="Honeycode Microblog">
      <svg class="svg-inline--fa fa-w-12" aria-hidden="true" data-prefix="fab" role="img" xmlns="http://www.w3.org/2000/svg" viewBox="20 50 350 450" data-fa-i2svg="">
<path fill="currentColor" d="M193 97l86.6 50v100l-86.6 50l-86.6 -50v-100zM285 255l86.6 50v100l-86.6 50l-86.6 -50v-100zM100 255l86.6 50v100l-86.6 50l-86.6 -50v-100z"></path>
</svg>
    </a></li>
    <li><a href="//linkedin.com/in/oran-looney" target="_blank" title="LinkedIn"><i class="fab fa-linkedin"></i></a></li>
    <li><a href="https://github.com/olooney" target="_blank"  title="github"><i class="fab fa-github"></i></a></li>
    <li><a href="https://stackoverflow.com/users/273231/olooney" target="_blank" title="StackOverflow"><i class="fab fa-stack-overflow"></i></a></li>
    <li><a href="https://stats.stackexchange.com/users/48250/olooney" target="_blank" title="CrossValidated"><i class="fa fa-flask"></i></a></li>

    <li>
      <a href="https://www.librarything.com/catalog.php?view=olooney&amp;offset=0&amp;shelf_rows=10&amp;previousOffset=0&amp;shelf=shelf" target="_blank" title="LibraryThing">
	    <i class="fas fa-book-reader"></i>
	  </a>
	</li>
    
  </ul>

  </nav>
</header>


  <div class="main" role="main">
    <article class="article">
      <img src="/post/playfair_files/lead.jpg" class="article-image" />
      
      <h1 class="article-title">Cracking Playfair Ciphers</h1>
      
      <hr class="article-title-bottom">
      <ul class="article-meta">
        <li class="article-meta-date"><time>June 28, 2023</time></li>
        <li class="article-meta-tags">
          <a href="/tags/math/">
            <i class="fas fa-tag"></i>
            Math
          </a>&nbsp;
        </li>
        <li class="article-meta-tags">
          <a href="/tags/python/">
            <i class="fas fa-tag"></i>
            Python
          </a>&nbsp;
        </li>
        <li class="article-meta-tags">
          <a href="/tags/visualization/">
            <i class="fas fa-tag"></i>
            Visualization
          </a>&nbsp;
        </li>
      </ul>
      
<aside class="toc">
  <nav id="TableOfContents">
<ul>
<li>
<ul>
<li><a href="#the-playfair-cipher">The Playfair Cipher</a></li>
<li><a href="#known-plaintext-attack">Known Plaintext Attack</a></li>
<li><a href="#guessing-plaintext">Guessing Plaintext</a></li>
<li><a href="#a-sense-of-rightness">A Sense of Rightness</a></li>
<li><a href="#simulated-annealing">Simulated Annealing</a></li>
<li><a href="#parallel">Parallel</a></li>
<li><a href="#cython">Cython</a></li>
<li><a href="#hyperparameter-optimization">Hyperparameter Optimization</a></li>
<li><a href="#conclusion">Conclusion</a></li>
</ul></li>
</ul>
</nav>
</aside>
      

<p>In 2020, the <a href="https://www.youtube.com/watch?v=-1oQLPRE21o">Zodiac 340 cipher was finally cracked</a> after more than 50
years of trying by amateur code breakers.  While the effort to crack it was
extremely impressive, the cipher itself was ultimately disappointing. A
<a href="http://practicalcryptography.com/ciphers/homophonic-substitution-cipher/">homophonic substitution cipher</a> with a minor gimmick of writing
diagonally, the main factor that prevented it from being solved much earlier
were the several errors made when encoding it.</p>

<p>Substitution ciphers, which operate at the level of a single character, are
basically children&rsquo;s toys, the kind of thing you might get a decoder ring for
from the back of a magazine. Homophonic substitution ciphers, which are designed
to prevent frequency analysis by using more than one cipher character to denote
frequent letters, are barely more secure - <a href="https://www.scientificamerican.com/article/scientists-decipher-50-letters-from-mary-queen-of-scotts-before-her-beheading1/">Mary, Queen of Scots was executed in 1587
after just such a cipher was intercepted and cracked</a>.</p>

<p>I want to tell you about an alternative cipher, which is much more secure than
substitution cipher, but still simple enough to encode and decode by hand
quickly. This particular cipher was successfully used as a field cipher in WWI
as it would take hours or days to crack before the invention of the computer.</p>

<p>And then, of course, we&rsquo;re going to crack it.</p>

<p>There&rsquo;s no practical purpose to this; I wanted to play around with code breaking
techniques, and modern ciphers are too secure to be anything but discouraging,
while substitution ciphers don&rsquo;t present much of a challenge. I found this
to be a rewarding middle ground and recommend the exercise to anyone who
wants to play around with hobby-level cryptography.</p>

<h2 id="the-playfair-cipher">The Playfair Cipher</h2>

<p>The cipher in question is called the <a href="https://en.wikipedia.org/wiki/Playfair_cipher">Playfair cipher</a>. as you can infer
from its name, it was invented by Charles Wheatstone in 1854; Playfair merely
popularized it. (Lest you think Wheatstone was cheated, rest assured that he
received due fame for the <a href="https://en.wikipedia.org/wiki/Wheatstone_bridge">Wheatstone bridge</a>, which was invented by Samuel
Hunter Christie.)</p>

<p>The Playfair cipher is designed to be done on paper, so places a great
deal of emphasis on ease of use over security. No addition module 256 here!</p>

<p>The reason it&rsquo;s more secure is not merely because it operates two characters at
a time, but because it mixes the two values together in a non-linear (but
reversible) way.  Modern block ciphers like AES use a <a href="https://en.wikipedia.org/wiki/Substitution%E2%80%93permutation_network">substitution-permutation
network</a> which work in a very similar way and are difficult to crack for
exactly the same reason.</p>

<p>We can visualize this strength using a heatmap. Here is the structure
of a simple substitution cipher:</p>

<p><img src="/post/playfair_files/substitution_heatmaps.png"></p>

<p>The patterns are obvious and simple; this cipher is not doing a good job of
hiding the message. In contrast, The heatmap for the Playfair cipher shows
reasonable levels of mixing:</p>

<p><img src="/post/playfair_files/playfair_heatmaps.png"></p>

<p>How secure is Playfair? Wikipedia has this to say:</p>

<blockquote>
<p>Playfair is no longer used by military forces because of the advent of
digital encryption devices. This cipher is now regarded as insecure for any
purpose, because modern computers could easily break it within microseconds.
<br>&mdash;<a href="https://en.wikipedia.org/wiki/Playfair_cipher">Wikipedia</a></p>
</blockquote>

<p>Really, microseconds? I&rsquo;m not so sure about that&hellip; let&rsquo;s be generous and say
we can implement the Playfair decryption in 3 lookup operations, and the
bigraph lookup up 1 lookup operation, all of which hit the L1 cache. That&rsquo;s
roughly 4 nanoseconds per bigraph, or 2 nanoseconds per character. We&rsquo;ll need
100 characters or more to have any hope of cracking the cipher, so that&rsquo;s 200
nanoseconds per candidate key that we check. That means we have to find a
solution while checking fewer than 5,000 keys. That&rsquo;s not much of a budget.  I
think the &ldquo;milliseconds&rdquo; used by Wikipedia is simply hyperbole, or perhaps a
confusion between the cost of a decryption vs. the cost of a crack. To see
why, let&rsquo;s try to estimate the strength of a Playfair key from first principles.</p>

<p>A Playfair key is a 5x5 grid of unique letters:</p>

<div id="playfairCanvas"><img src="/post/playfair_files/texture.png"></div>

<p>At first glance that suggests there are $25! = 1.5 \times 10^{25}$ possible
keys.  However, if we study the algorithm, we see that all of the operations
wrap around at the edges - that is, if the algorithm tells you to move one
column to the right and you&rsquo;re already at the 5th column, you wrap around back
to the first column. The same is true for rows. That means Playfair keys can be
visualized as being on a torus:</p>

<div id="playfairTorus"><img src="/post/playfair_files/torus.png"></div>

<p>We can effectively rotate all the rows or columns of a key an obtain an
equivalent key - they both both before the same encryption and decryption. This
means there there are effectively only $25!/25 = 24! = 6.2 \times 10^{23}$ possible
keys.</p>

<p><link rel="stylesheet" href="/post/playfair_files/playfair.css"></p>

<script type="module">
    import { renderPlayfairCanvas, renderPlayfairTorus } from '/post/playfair_files/playfair_torus.js';
    renderPlayfairTorus('MYNAEISORWLBCDFGHKPQTUVXZ', 'playfairTorus');
</script>

<p>There are, broadly speaking, two ways to attack ciphers. The first is to search
the space of all possible keys, decrypting the ciphertext with each candidate
key and hunting for some kind of leaked information that might betray the fact
that we&rsquo;re getting closer. The second is obtain, by spycraft or guesswork, some
plaintext message for which we also have the corresponding encrypted ciphertext
(although the key is still unknown) and to mathematically deduce the key. We&rsquo;ll
do both, but let&rsquo;s start with the second approach first, as it&rsquo;s more fun - more
like solving a puzzle and less like groping around in the dark.</p>

<h2 id="known-plaintext-attack">Known Plaintext Attack</h2>

<p>Known plaintext attacks sound rather pointless at first glance. &ldquo;You&rsquo;re
telling me you can crack this cipher for me, but only if I give you the
original message? I think I&rsquo;ll take my business to a different cryptographer.&rdquo;</p>

<blockquote>
<p>It rather involved being on the other side of this airtight hatchway.
<br>&mdash;<a href="https://devblogs.microsoft.com/oldnewthing/20060508-22/?p=31283">Raymond Chen</a>, quoting Douglas Adams</p>
</blockquote>

<p>However, there are several ways to obtain probable plaintext. For example, you
might guess it says &ldquo;Keine besonderen Ereignisse,&rdquo; German for &ldquo;Nothing to
Report,&rdquo; a stock phrase often used by Germans in WWII and which was used to
<a href="https://en.wikipedia.org/wiki/Cryptanalysis_of_the_Enigma">crack the Enigma machine</a>.  Nor is the exercise pointless - once you&rsquo;ve
cracked the cipher and obtained the secret key you&rsquo;ll be able to use that key
to decrypt and read other messages that you don&rsquo;t yet know, as well as encrypt
fake messages.</p>

<p>Stack Overflow user Ilmari Karonen has helpfully <a href="https://crypto.stackexchange.com/questions/35722/how-to-find-the-keyword-of-the-playfair-cipher-given-the-plaintext-and-the-ciph">summarized the logic
here</a>.  Some of the tricks are obvious, but others, like the chains
which allow us to fill in an entire row or column, including the exact order,
are extremely clever.</p>

<p>We have options about how we represent this problem to Z3. I found the most
natural way was to use a 25x2 matrix, where each row represents a letter. The
first column is the x-coordinate of that letter in the 5x5 playfair key grid,
and the second is the y-coordinate. So every element of the matrix will be an
integer between 0 and 4, and we&rsquo;ll also need to make sure that a letter can go
in one and only one cell.  Because they constraints apply to all Playfair key
grids, we&rsquo;ll call them the universal constraints.</p>

<pre><code>from z3 import *

X = [[Int('x_%i_%i' % (i, j)) for j in range(2)] for i in range(25)]
position_constraints = [
    And(0 &lt;= X[i][j], X[i][j] &lt;= 4) 
    for j in range(2) 
    for i in range(25)
] 
distinct_constraints = [
    Distinct([X[i][0]*5 + X[i][1] 
    for i in range(25)])
]
universal_constraints = position_constraints + distinct_constraints
</code></pre>

<p>We&rsquo;ll write some helper function so help keep track of the constraints. Most of
the information will come in the form of learning that two letters are in the
same row/column, or in adjacent rows/columns, so we&rsquo;ll make it easy to describe
such constraints.</p>

<pre><code>def row_col_constraint(*indices, spacing=0, orientation=0):
    constraints = [
        (X[indices[i]][orientation] + spacing) % 5 == X[indices[i+1]][orientation] 
        for i in range(len(indices) - 1)
    ]
    if len(constraints) &gt;= 2:
        return And(*constraints)
    else:
        return constraints[0]

def same_row(*indices):
    return row_col_constraint(*indices, spacing=0, orientation=0)

def same_col(*indices):
    return row_col_constraint(*indices, spacing=0, orientation=1)

def next_row(*indices):
    return row_col_constraint(*indices, spacing=1, orientation=0)

def next_col(*indices):
    return row_col_constraint(*indices, spacing=1, orientation=1)
</code></pre>

<p><img src="/post/playfair_files/rectangle_constraint.png"></p>

<p>Now we have to consider the various special cases. For example, if we see that
the plaintext &ldquo;XY&rdquo; maps to ciphertext &ldquo;AB&rdquo;, and we also see that &ldquo;AB&rdquo; maps to
&ldquo;XY&rdquo;, then we know that X, Y, A, B must form a rectangle in the key grid.</p>

<pre><code># XY -&gt; AB and AB -&gt; XY, so XA/BY form a rectangle
def rectangle_constraint(plain_digraph: str, cipher_digraph: str) -&gt; list:
    p1, p2 = (playfair_ord(c) for c in plain_digraph)
    c1, c2 = (playfair_ord(c) for c in cipher_digraph)

    return And(
        same_row(p1, c1),
        same_row(p2, c2),
        same_col(p1, c2),
        same_col(p2, c1),
        Not(same_row(p1, p2)),
        Not(same_col(p1, p2)),
        Not(same_row(c1, c2)),
        Not(same_col(c1, c2))
    )
</code></pre>

<p>There are several other such special cases to consider. Such as this chain constraints three in a row, either in a column or row:</p>

<p><img src="/post/playfair_files/chain_constraint.png"></p>

<p>In code:</p>

<pre><code># XY -&gt; PQ, PQ -&gt; YA =&gt; row/col of XPYQA
def chain_constraint(plain_digraph: str, cipher_digraph: str, next_digraph) -&gt; list:
    p1, p2 = (playfair_ord(c) for c in plain_digraph)
    c1, c2 = (playfair_ord(c) for c in cipher_digraph)
    n1, n2 = (playfair_ord(c) for c in next_digraph)

    return Or(
        And(same_row(p1, c1, p2, c2, n2), next_col(p1, c1, p2, c2, n2)),
        And(same_col(p1, c1, p2, c2, n2), next_row(p1, c1, p2, c2, n2))
    )

# XY -&gt; PQ, PQ -&gt; BX =&gt; row/col of YQXPB
# omitted for brevity...

# XY -&gt; YZ so XYZ share a row or column and are all adjacent
def adjacent_constraint(plain_digraph: str, cipher_digraph: str) -&gt; list:
    p1, p2 = (playfair_ord(c) for c in plain_digraph)
    c1, c2 = (playfair_ord(c) for c in cipher_digraph)
    assert p2 == c1

    return Or(
        And(same_row(p1, p2, c2), next_col(p1, p2, c2)),
        And(same_col(p1, p2, c2), next_row(p1, p2, c2))
    )

# XY -&gt; WX so YXW share a row or column and are all adjacent
# omitted for brevity...
</code></pre>

<p>However, even if we don&rsquo;t see any special pattern, we do actually glean a small
amount of information from every digraph we see. Remember, there are only three
cases for encoding a pair: the rectangle case, the same row case, and the same column case.
In all three, the ciphertext letter is <em>always</em> in the same row or the same column as
the plaintext letter. If it&rsquo;s the same column, then the ciphertext letter is immediately
below the plaintext character:</p>

<p><img src="/post/playfair_files/simple_constraint.png"></p>

<p>This is true for both the first and second character of each digraph.  In code:</p>

<pre><code># XY -&gt; AB (no other information)
def simple_constraint(plain_digraph: str, cipher_digraph: str) -&gt; list:
    p1, p2 = (playfair_ord(c) for c in plain_digraph)
    c1, c2 = (playfair_ord(c) for c in cipher_digraph)

    return And(
        Or(same_row(p1, c1), And(same_col(p1, c1), next_row(p1, c1))),
        Or(same_row(p2, c2), And(same_col(p2, c2), next_row(p2, c2)))
    )
</code></pre>

<p>It&rsquo;s easy to scan through the known text and quickly build up a map of digraphs. This is also
a good opportunity to validate that the ciphertext really does look like it came from Playfair cipher.</p>

<pre><code>def parse_bigraph_map(plaintext: str, ciphertext: str) -&gt; dict:
    &quot;&quot;&quot;
    Parse and validate matching plaintext and ciphertext. A dict of distinct
    plaintext to ciphertext bigraphs mappings are returned, including all 
    mirrored mappings. This checks for obvious violations of the Playfair
    cipher algorithm and will raise an Exception if any are found.
    &quot;&quot;&quot;

    # we only care about unique/distinct digraph mappings of the form AB -&gt; XY 
    # and will ignore duplicates.
    bigraph_map = {}
    for plain_bigraph, cipher_bigraph in zip(bigraphs(plaintext), bigraphs(ciphertext)):
        # XY -&gt; AB =&gt; YX -&gt; BA, add both the original and mirrored versions to the map
        bigraph_map[plain_bigraph] = cipher_bigraph
        bigraph_map[ plain_bigraph[::-1] ] = cipher_bigraph[::-1]

    return bigraph_map
</code></pre>

<p>We have to examine each digraph mapping to see if we have enough information to identify a special
case:</p>

<pre><code>def constraints_from_known_text(plaintext: str, ciphertext: str, verbose_level=0) -&gt; list:
    &quot;&quot;&quot;
    Analyze the plain/ciphertext bigraph pairs of a message and make deductions about
    the structure of the key. These are returns as a list of Z3 constraints.
    &quot;&quot;&quot;
    bigraph_map = parse_bigraph_map(plaintext, ciphertext)

    # build up constraints
    constraints = []
    seen_already = set()
    for plain_bigraph, cipher_bigraph in bigraph_map.items():
        # we only need to handle one of each mirror version.
        if plain_bigraph[::-1] in seen_already:
            continue
        else:
            seen_already.add(plain_bigraph)

        # XY -&gt; YZ =&gt; XYZ in row or col
        if plain_bigraph[1] == cipher_bigraph[0]:
            constraints.append( adjacent_constraint(plain_bigraph, cipher_bigraph) )
            continue

        # XY -&gt; ZX =&gt; YXZ in row or col
        # omitted for brevity

        if cipher_bigraph in bigraph_map:
            next_bigraph = bigraph_map[cipher_bigraph]

            # XY -&gt; AB, AB -&gt; XY =&gt; rectangle
            if next_bigraph == plain_bigraph:
                constraints.append( rectangle_constraint(plain_bigraph, cipher_bigraph) )
                continue

            # XY -&gt; PQ, PQ -&gt; YA =&gt; row or col of XPYQA
            if plain_bigraph[1] == next_bigraph[0]:
                constraints.append( 
                    chain_constraint(plain_bigraph, cipher_bigraph, next_bigraph))
                continue

            # XY -&gt; PQ, PQ -&gt; BX =&gt; rol or col of YQXPB
            # omitted for brevity

        # AB -&gt; XY
        constraints.append( simple_constraint(plain_bigraph, cipher_bigraph) )

    return constraints
</code></pre>

<p>Now that we&rsquo;ve built up a set of Z3 constraints describing our specific problem, we can ask Z3 to find
a key meeting all of the above constraints:</p>

<pre><code>def solve_playfair_constraints(dynamic_constraints):
    solver = Solver()

    solver.add(universal_constraints)
    solver.add(dynamic_constraints)

    # Check for solution
    check = solver.check()
    if  check == sat:
        model = solver.model()
        grid = model_to_grid(model)
        return sat, grid
    else:
        return check, None
</code></pre>

<p>We can also get Z3 to keep generating different unique solutions through the simply trick of
adding a constraint to block the previous solution and re-solving:</p>

<pre><code>def iter_playfair_constraints(dynamic_constraints):
    solver = Solver()

    solver.add(universal_constraints)
    solver.add(dynamic_constraints)

    # Check for solution
    while True:
        check = solver.check()
        if  check == sat:
            model = solver.model()
            grid = model_to_grid(model)
            yield grid

            # block the found solution and try again
            solver.add(Or([
                X[i][j] != model[X[i][j]] 
                for i in range(25) 
                for j in range(2)
            ]))
        else:
            break
</code></pre>

<p>When given only the first 100 characters as known plaintext, this approach was able to recover
almost the entire key, except for a transposition of Z and X in the last row.</p>

<pre><code>M Y N A E
I S O R W
L B C D F
G H K P Q
T U V Z X
</code></pre>

<p>This is enough to recover most of the message:</p>

<p><img src="/post/playfair_files/kpa_visual_diff.png"></p>

<p>I was very impressed with Z3&rsquo;s capabilities for this task. It was quite easy to express
the constraints in its DSL and its performance was really good. The exact time it takes
to find a key depends on how many characters of known plaintext we are able to provide;
it usually requires about 100 to identify the correct key (or at least one close enough
to work in practice) and that only takes a few seconds. However, that&rsquo;s still three orders
of magnitude out from the &ldquo;microseconds&rdquo; the Wikipedia article claimed, and tracking down
known plaintext is kind of a pain, so let&rsquo;s try another approach.</p>

<h2 id="guessing-plaintext">Guessing Plaintext</h2>

<p>TODO</p>

<p>ER/RE pairs. This gets us a rather long list of possible plaintext
words to try. Having Multiple snippets of probable plaintext is much less
useful than known plain text, because we&rsquo;d have to feed every combination into
our constraint solver. If we&rsquo;re going to be searching blindly, we might
as well use the simulated annealing technique.</p>

<h2 id="a-sense-of-rightness">A Sense of Rightness</h2>

<p>More importantly, how do we know if we&rsquo;re getting close? Detecting correct
English is pretty easy; how do we detect partially decrypted, garbled English
and distinguish it from pure gibberish?</p>

<p>The FBI, in a report on Graysmith&rsquo;s 1979 attempt to crack the Zodiac 340
cipher, made this rather damning statement:</p>

<blockquote>
<p>When a cryptogram has been decrypted properly there is an unmistakable sense
of rightness about the solution. This sense of rightness is completely absent
in the proposed solution.  <br>&mdash; <a href="http://zodiackillerfacts.com/main/the-340-cipher-dead-ends/">FBI</a></p>
</blockquote>

<p>If we are to automate the search, we need to quantify this &ldquo;sense of
rightness.&rdquo;</p>

<p>The traditional approach is to use trigrams or quadgrams and compare
frequencies against the known frequencies of a target language such as English.
For example, the trigram &ldquo;THE&rdquo; is very common in English, while &ldquo;QXZ&rdquo; is very
uncommon, so if we see &ldquo;THE&rdquo; in the recovered plaintext we can see know we are
on the right track.</p>

<p>An out of the box approach might work to a certain degree on Playfair but is
far from optimal. To do a better job, we need to think carefully about the
specific of the Playfair algorithm.</p>

<p>First, the pre-processing steps of replacing &ldquo;J&rdquo; with &ldquo;I&rdquo; and breaking up pairs
like &ldquo;LL&rdquo; by inserting an &ldquo;X&rdquo; to get &ldquo;LX&rdquo; mess up the frequencies a bit. If
we&rsquo;re going to use n-grams, we should recalculate frequency based on already
pre-processed text. Second, Playfair works on pairs of letters. Especially very
early in the search process, it&rsquo;s a promising signal if any pair of letters
decodes to a common English bigram. However, bigrams are a fairly weak way of
detecting correct text.</p>

<p>As an aside, I tried using ChatGPT (via the OpenAI API) to detect English. This
works but is very slow - multiple seconds to check one message, when we need to
be trying thousands or even millions of keys. However, it does work really
well; ChatGPT can segment and punctuate text that&rsquo;s been run together, and even
tell if a message is messy/malformed English or complete gibberish. This is
actually quite impressive because word segmentation is a classic example of a
problem that needs something like dynamic programming to do efficiently, but
ChatGPT can somehow do it with a single forward pass through the text.
Unfortunately, we need to check thousands of texts per second during the course
of a single crack, and ChatGPT is both far too slow and far too expensive to do
that.</p>

<p>I found a good compromise was to apply word segmentation, and then to check the
resulting works against an English dictionary, with partial credit for typos or
misspellings (which may be decryption errors, or intentional mistakes designed
to make the message harder to crack.) For this purpose we use an off-the-shelf
<a href="https://pypi.org/project/wordsegment/">Python package for word segmentation</a>, implemented a <a href="https://en.wikipedia.org/wiki/BK-tree">BK-tree</a> to
find English words and near words, and wrote a heuristic function to gauge the
&ldquo;Englishness&rdquo; of a text:</p>

<p>This approach is still a little slow (still less than a second) but seemingly
quite reliable. Nonsense gets scores under 10%, which even very bad/malformed
English usually gets over 80%.  It&rsquo;s not fast enough to use for inner loop of
the search, but it is fast and reliable enough to automatically detect when
we&rsquo;ve truly cracked the cipher.</p>

<p>So, to automate the &ldquo;sense of rightness&rdquo; we&rsquo;ll use a threefold approach:</p>

<ol>
<li>Use bigrams, but only on pairs of letters decoded together. This helps early on.</li>
<li>Also use trigrams, to help zero in on the final key once it starts to make sense.</li>
<li>Finally, use a slower method to verify that we&rsquo;ve found a real English sentence.</li>
</ol>

<h2 id="simulated-annealing">Simulated Annealing</h2>

<p>Dual annealing, etc. Consider this function:</p>

<p>\[
    f(x) = \sum_{k=1}^{1000} \frac{{|\sin(k\pi x)|}}{k}
\]</p>

<p>Or in Python:</p>

<pre><code>def f(x, n=1000):
    return sum( abs(sin(k*pi*x))/k  for k in range(1, n+1) )
</code></pre>

<p>This function has 84,779 local minima between 0.2 and 0.8:</p>

<p><img src="/post/playfair_files/many_local_minima.png"></p>

<p>How do you find the single global minima? One answer is simulated annealing:</p>

<pre><code>from scipy.optimize import dual_annealing
dual_annealing(f, [(0.2, 0.8)], x0=[0.20001], callback=print)
</code></pre>

<p>-</p>

<pre><code>[0.5008241] [4.56639717] 0
[0.5] 4.089060034436875 1
 message: ['Maximum number of iteration reached']
 success: True
  status: 0
     fun: 4.089060034436875
       x: [ 5.000e-01]
     nit: 1000
    nfev: 2145
    njev: 72
    nhev: 0
</code></pre>

<h2 id="parallel">Parallel</h2>

<p>Pure simulated annealing</p>

<pre style="font-size: 0.77em; background-color: black; color: green; padding: 0.5em;">
Cipher Text:
VYFAOAMEUGUGMQEXNWCWWSCOBHMFZIQYWAUGYWMEWCXIEAHZLGLMNYAZMZIUQYAFQMWCZILGLTGUGLYWYPRLFAMVWRZNWCISRBINCWIPIVZMYCNYEANBCNM
ZAFHSUGROMWMVQYVORILMKSBFIUQYQNSBVIVYVIBFKRFWDRIUQYOCIXUBXMWOXMACRYIUQYOSFMMVWYMVOMMFUGAQMXGUIVQYXICNAWNZMEBILMWYBLCOBM
VYFAIXQYOSCTAWMHCIIRLZQYNICOMXLMWUMALMPBNFRGQYIXQYSQSOQAWOWCUGMEOKWMMVKCYOZMDTDMMLCOIBMZUGMYHTRLMNSVUGWRTHGUQYPROPAMRUR
YACNSYBPYDTBTMCCKGVQYWYDOMZIUPYMGWMFYAMMXGUQYFNFMIURMGMRXYWXISHVUWAYMYLAWUGAQMXGSWBDRTHGUISUGBKMDFMMKYWYMEAVIMCEBRWUGWF
RWUGAHAWOSIUEAFBMZOCUZUGAZMALTYEMLDVKCIYROFAZMSASVDAWAORCTWQRWUGROWFKSPRWAVIVYFAIXNPMZGSOSSVOAMNUGNFMFYWMLMDWAMDAGWRILW
YWYMCLTGUMAYMMVFYNSACNIIXMDKCAGWAQYYOSREV

13:33:30  17896 LWFDCOPEIZMANQRHSKGYUBXTV YRWNPMNOTHTHRNFKAFDLBALZUSNLIERGBPTHSCNOLDTEPNYODHUORKRPROOTRGNWNRLDIR    23%
13:33:30  18092 WTPQMZLVOEFYKHXRNCGISBDAU LKHSQGUMAIAIQPMERTRPSRGVAYWXERTHQSAIFTUMPREXOUFOONETYLSOWEXITHSHPQPROW    24%
13:33:30  20452 YASDBPWEQZFLGTNMCHKORXUVI RDLYCBHPHEHEKPWULZLAEAMKSOFPBOPDAXHEAPHPALRVWSOEFLFCFBBWOPVXPDYLPKALQE    17%
13:33:34  17896 NVMWFXQTZIBASOYPRUDHLCEKG FAVYSBEUHEHEVTLTFMKVMOKAYPVWTZIAVOHEOFEUVKIZCSDIGKENFBOQWTTHIAYVTVVKTX    28%
13:33:39  17896 NOMWFXQTZIBASRYPVUDHLCEKG HAOYCQEUHEHEOTLTFMKOMRVCYPOWTZIAORHERFEUOKIZCSDIGKENFBRQWTTHIAYOTOOKTX    29%
13:33:43  17896 NOMFWXQTIZBASYRPVUHDLCEGK HAOYCQEUHEHEOTLTWFKOMRVCYPOMITIAORHERFEUOKZTCSDIKEENFBRQWTTHIAYOTOOKIX    29%
13:33:44  16908 EYABDOPWFLQHIXZKSGMRCNTUV NDWBWEKBTMTMKXBQTPTOPGKEYXXBXHHEATTMAPKBOTIHDYQXWRFRSNDIRXXTHEBWXKOTX     31%
13:33:53  20452 UEYNTOVXMGPBRFALQHKWZDSCI XERFGPVNTOTOVKYVTKIKHIZMRQNMICHEAGTOTHVNKIGSTBLSWOKOYEPIOCZTHEFRKVKIDL    31%
13:33:54  16908 OPWAFQHIZRCVTLUKSGXDEYMNB HSAWFWYBTDTDEINKMATOPGQEYRBWIHHEPWTDMPYBOTGZNOQITTNMENANIRTHEWAIEOTIR     34%
13:34:08  16908 KDGXSQRIZHCUTLVOFWAPEBMNY HPOWPWBYTDTDEINKMATOPGQCYRBWIRHEFWTDMPBYOTGZNOZITTNMNLXNIRTHEWOIEOTIH     34%
13:34:12  20452 UEYITPBRACOMXKGLQHNWZFDSV DTSBKPBFTOTOBMYMHNTGNVPGRQBQSUHENCTOTHBFGTKYIBLDWOQOHIPSOFYTHEBSMBGTFL    35%
13:34:14   9896 SMOADKNCFPBWRVIUYEGHZTLXQ WGAXMOOYHEHEDTGLMNNRBMOLIUANQBTHVMHEWNOYRNQVGOUQXETOMWSSTBHTHXATDRNQX     37%
13:34:19   9896 KNCFPSMOADBWRVIUYEGHZTLXQ WGXFMOOYHEHEDTGLTMNRBMLCIUANQBTHVMHEWMOYRNQVGOUQXETOTWSSTBHTHFXTDRNQX     39%
13:34:26   6440 ZKTUFPEMYONARSCBQGHWXVIDL DEKCECEPTHTHEGPVCBOCHCOFWGOTTXHEQCTHOHEPCOLVKEBUIWIOSPNKPTDTHECKGECOKB    46%
13:34:35   6440 WGPQHFTOVUSCXNLAMDEYRIBZK UEWSFDADTHTHEGDNSQSGRFXTKPATBRHERSTHAHADGSCBDYQKCHCYLEEREIKTHESWGEGSE     50%
13:34:42  13048 DIWZNQGKHPVTXUCEMOYBFLASR UERLXOEBTHTHEGOVZIXNZAXBYPELWDHEAOTHOZEBNXTWOFZSMIMTZBSWYIZTHELRGENXDH    54%
13:34:44   6440 DFZISKLWPRUXVTOHNQGBYAEMC UEANXCEATHTHEGAVQLERRZBRGBAIFZHELETHEKEARETFAYQDPNPAHAEFEIDTHENAGEREEV    57%
13:34:47  13048 HQGPZNWIBCYEMADSFRLOUVTKX UELELDEYTHTHEGDVCNBNNFZDNPERGCHEBETHENEYNBTCYMZPRPRAHNDPDGNTHEELGENBPH    60%
13:34:55  13048 FPDLBRSOIWEYAMNZUVTCQHXGK UADEDOANTHTHEGAQWBNBIRVWPKELTRHEONTHNSANBNGONYQUGTGIMEEVETSTHEEDGEBNE     60%
13:34:57   6440 WLRBFPICSOEMYNAQGHKDZTUVX UNXOFOEATHTHEGAZEBPRBPISRKALTPHEFETHEREARPTOANQUTMTIYMEETCTHEOXGERPQE     64%
13:35:00  13048 ISORWLBKCFGHDPQTUVXZMYNAE UNCERNEATHTHEGAZEOFRRIKRSBELTWHERETHESEARFTRANQUILITYMEETSTHEECGERFQF     79%
13:35:01   6440 BCDFLUVXZTHKPQGYNAEMSORWI UNDERNEATHTHEGAZEOFORIONSUELTWHERETHESEAOFTRANQUITIGYMEETSTHEEDGEOFF      83%
13:35:04  13048 ISORWLBCDFGHPKQTUVXZMYNAE UNDERNEATHTHEGAZEOFORIONSBELTWHERETHESEAOFTRANQUILITYMEETSTHEEDGEOFQF     85%
13:35:06   6440 BCDFLHKPQGUVXZTYNAEMSORWI UNDERNEATHTHEGAZEOFORIONSBELTWHERETHESEAOFTRANQUILITYMEETSTHEEDGEOFQF     87%

Candidate solution found!
Key: BCDFLHKPQGUVXZTYNAEMSORWI
Bigraph/Trigraph Score: 87%

Plain Text:
UNDERNEATHTHEGAZEOFORIONSBELTWHERETHESEAOFTRANQUILITYMEETSTHEEDGEOFTWILIGHTLIESAHIDDENTROVEOFWISDOMFORGOTTENBYMANYCOVET
EDBYTHOSEINTHEKNOWITHOLDSTHEKEYSTOUNTOLDPOWERASTHENORTHSTARSTANDSASTHESILENTSENTINELTHEPATHTOTHETROVEREVEALSITSELFONLYU
NDERTHESILVERYGLOWOFTHEMOONATITSZENITHDECIPHERTHEWHISPERSOFTHEANCIENTCONSTELLATIONSLETTHEMGUIDEYOUTHROUGHTHEDARKNESSAND
YOUSHALLUNLOCKTHESECRETSTHATLIEBENEATHTHECELESTIALTAPESTRYBUTREMEMBERTHEPATHISFRAUGHTWITHCHALLENGESMEANTONLYFORTHEWORTH
YPERSISTANDLETNOTTHEENIGMATICCOSMOSDETERYOURRESOLVEFORTHOSEWHODARETOUNDERTAKETHISIOURNEYTHECELESTIALREALMPROMISESENLIGH
TENMENTBEYONDMORTALCOMPREHENSION

Segmented Plain Text:
UNDERNEATH THE GAZE OF ORIONS BELT WHERE THE SEA OF TRANQUILITY MEETS THE EDGE OF TWILIGHT LIES A HIDDEN TROVE OF
WISDOM FORGOTTEN BY MANY COVETED BY THOSE IN THE KNOW IT HOLDS THE KEYS TO UNTOLD POWER AS THE NORTHSTAR STANDS AS THE
SILENT SENTINEL THE PATH TO THE TROVE REVEALS ITSELF ONLY UNDER THE SILVERY GLOW OF THE MOON AT ITS ZENITH DECIPHER THE
WHISPERS OF THE ANCIENT CONSTELLATIONS LET THEM GUIDE YOU THROUGH THE DARKNESS AND YOU SHALL UNLOCK THE SECRETS THAT
LIE BENEATH THE CELESTIAL TAPESTRY BUT REMEMBER THE PATH IS FRAUGHT WITH CHALLENGES MEANT ONLY FOR THE WORTHY PERSIST
AND LET NOT THE ENIGMATIC COSMOS DETER YOUR RESOLVE FOR THOSE WHO DARE TO UNDERTAKE THIS I OUR NEY THE CELESTIAL REALM
PROMISES ENLIGHTENMENT BEYOND MORTAL COMPREHENSION

English Word Score: 91%
Accepted solution.
</pre>

<h2 id="cython">Cython</h2>

<p>Python is very slow at character-by-character string manipulation. Unfortunately,
that&rsquo;s exactly what the inner loop of <code>Playfair.decrypt()</code> is doing. We can use Cython
to optimize the performance critical section of the code:</p>

<pre><code>@cython.boundscheck(False)
@cython.wraparound(False)
cpdef str playfair_decrypt(str cipher_text, str key):
    &quot;&quot;&quot;
    Decrypt the given cipher text using the Playfair cipher with the provided key.

    Arguments:
    cipher_text -- The encrypted text. Must contain an even number of uppercase letters.
    key -- The key for decryption. Must be exactly 25 uppercase letters.

    Returns:
    The decrypted text.
    &quot;&quot;&quot;
    cdef int i, j
    cdef int n = len(cipher_text)

    # populate a reverse lookup table
    cdef int[25][2] reverse_lookup
    for i in range(25):
        j = playfair_ord(key[i])
        reverse_lookup[j][0] = i // 5
        reverse_lookup[j][1] = i % 5

    # Allocate memory for the result
    cdef char* decrypted_text = &lt;char*&gt;malloc(n+1)
    if not decrypted_text:
        raise MemoryError()

    # decrypt playfair cipher
    cdef int x1, x2, y1, y2
    try:
        # Loop over the characters in cipher_text
        for i in range(0, n, 2):
            x1, y1 = reverse_lookup[playfair_ord(cipher_text[i])]
            x2, y2 = reverse_lookup[playfair_ord(cipher_text[i+1])]

            if x1 == x2:
                decrypted_text[i] = key[5*x1 + (y1-1)%5]
                decrypted_text[i+1] = key[5*x2 + (y2-1)%5]
            elif y1 == y2:
                decrypted_text[i] = key[5*((x1-1)%5) + y1]
                decrypted_text[i+1] = key[5*((x2-1)%5) + y2]
            else:
                decrypted_text[i] = key[5*x1 + y2]
                decrypted_text[i+1] = key[5*x2 + y1]

        # Null-terminate the string
        decrypted_text[n] = b'\0'

        # Convert the byte array back to a Python string to return it
        return decrypted_text.decode('utf-8')

    finally:
        # Free the allocated memory
        free(decrypted_text)
</code></pre>

<h2 id="hyperparameter-optimization">Hyperparameter Optimization</h2>

<p>TODO: choosing optimal temperature and cooling rate parameters for simulated annealing.</p>

<pre><code>def crack(ciphertext, params):
    for _ in range(MAX_ATTEMPTS):
        key, score = mp.parallel_crack(
            ciphertext,
            initial_temperature=params['initial_temperature'],
            cooling_rate=params['cooling_rate']
        )
        score, english = evaluate(ciphertext, key)
        if english &gt; mp.acceptance_threshold:
            break
    return key, score, english
</code></pre>

<p>We want to crack ciphers quickly, so we&rsquo;ll time each attempt</p>

<pre><code>def objective(params):
    for i in range(N_REPEATS):

        # create a new problem each repeat
        true_key = PlayfairCipher.make_random_key()
        cipher = PlayfairCipher(true_key)
        ciphertext = cipher.encrypt(plaintext)

        # measure time to crack
        start_time = time.time()
        key, score, english = crack(ciphertext, params)
        end_time = time.time()
        duration = end_time - start_time

    # hyperopt boilerplate omitted 

    return {
        'loss': df['duration'].mean(),
        'loss_variance': df['duration'].var(),
        'status': STATUS_OK,
        # other metrics omitted
    }
</code></pre>

<p>Let&rsquo;s ask <code>hyperopt</code> to find us the optimal parameters.</p>

<pre><code>def hyperoptimize(trials=None):
    if trials is None:
        trials = Trials()

    space = {
        'initial_temperature': hp.loguniform(
            'initial_temperature', 
            low=np.log(1e-5), 
            high=np.log(1e-3)),
        'cooling_rate': hp.loguniform(
            'cooling_rate', 
            low=np.log(0.0001), 
            high=np.log(0.0003)),
    }

    best = fmin(
        fn=objective,
        space=space,
        algo=tpe.suggest,
        trials=trials,
        max_evals=N_TRIALS)

    return best, trials
</code></pre>

<p>When using the best parameters, we can crack messages in about 30 seconds.</p>

<p><img src="/post/playfair_files/hyperopt_initial_temperature.png"></p>

<p><img src="/post/playfair_files/hyperopt_cooling_rate.png"></p>

<h2 id="conclusion">Conclusion</h2>

<p>It&rsquo;s clear that the &ldquo;microseconds&rdquo; used in the Wikipedia article is hyperbole.
Microseconds is only enough to try a handful of keys, and Playfair is not
so weak that you can zero in on the solution that quickly. Nor is the problem
&ldquo;embarrassingly parallel&rdquo; - you can run lots of parallel attacks across a large
server farm, but you can&rsquo;t run $24!$ separate processes, or even make a dent
in it with brute force. You have to use something clever like simulated annealing
or constraint solving, and those are fundamentally sequential.</p>

<p>Still, the Playfair cipher is indeed quite weak - an amateur cryptographer with a
desktop and a couple of free weekends can write a program which will crack
it in under a minute. Don&rsquo;t use it for your important secrets! But do use it
for fun and games, as it&rsquo;s delightful.</p>

<p>One surprising thing I learned is that ChatGPT can solve the word segmentation
problem quite well, and it can even add punctuation and capitalization back
into the message. While LLMs  are far too slow to participate in the
performance intensive crack (we can use simpler heuristics like trigrams for
that,) their ability to make semantic sense of partially mangled text might
still be useful in automating the &ldquo;sense of rightness&rdquo; which hitherto has been
left to human cryptographers.</p>

    </article>

    <hr>


    <ul class="pager article-pager">
      <li class="pager-newer pager-noitem">&lt; Newer</li>
      <li class="pager-older">
        <a href="/post/my-dinner-with-chatgpt/" data-toggle="tooltip" data-placement="top" title="My Dinner with ChatGPT">Older &gt;</a>
      </li>
    </ul>
  </div>


<div class="site-footer">
  <div class="copyright">
	  &copy; Copyright 2023 Oran Looney
  </div>
  <ul class="site-footer-items">
  </ul>
  <div class="powerdby">
    Powered by <a href="https://gohugo.io/" target="_blank">Hugo</a>
  </div>
</div>
<script src="/js/script.js"></script>
<script src="/js/custom.js"></script>


<script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS_HTML"></script>
<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  tex2jax: {
    inlineMath: [ ['$','$'], ["\\(","\\)"] ],
    displayMath: [ ["\\[","\\]"] ],  // ['$$','$$'], 
    processEscapes: true,
    processEnvironments: true
  },
  // Center justify equations in code and markdown cells. Elsewhere
  // we use CSS to left justify single line equations in code cells.
  displayAlign: 'center',
  "HTML-CSS": {
    styles: {'.MathJax_Display': {"margin": 0}},
    linebreaks: { automatic: true }
  },
  TeX: { extensions: ["color.js"] }
});
</script>


<link rel="stylesheet"
	href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css">
<script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js"></script>
<script>
  hljs.configure({
    languages: ['python', 'r', 'javascript']
  })
  hljs.initHighlightingOnLoad()
</script>



</body>
</html>
